CMake Notes
///////////////////////////////////////////////////////////////////////////////////
//video 1: Installing cmake (linux)
// https://www.youtube.com/watch?v=_yFPO1ofyF0&list=PLK6MXr8gasrGmIiSuVQXpfFuE1uPT615s&index=2
///////////////////////////////////////////////////////////////////////////////////

cmake --version

///////////////////////////////////////////////////////////////////////////////////
//video 2:
///////////////////////////////////////////////////////////////////////////////////
    folder structure:
        base
            -CMakeLists.txt
            -build
                main.cpp
    
    CMakeLists.txt
        -basic file describing project
        -requires
            - project name
            - cmake version
        -typically where all cmake scripts go
    
    cmake_minimum_required(VERSION 3.11.0)

    running cmake
        command line
            -cmake [options] <path-to-source>
                -appears to drop solution files in directory cmake ran
                -path-to-source appears to be where the CMakeLists.txt is
        ccmake 
            -text user interface in terminal
            -doesn't appear installed on my machine
        gui

///////////////////////////////////////////////////////////////////////////////////
//Video 3: Building something from src
///////////////////////////////////////////////////////////////////////////////////
    cmds:
        cmake --build <dir> [options] [-- [native-options]]
        cmake --build ./cmake_cache_directory/

        (example useage)
            cd build
            cmake ..                            //generates cmake cache
            cmake --build . --config release    //builds the output 

    script cmds:
        add_executable(name file1.cpp, file2.cpp)
    
    -you can run cmake in a preconfigured binary folder (rather than the location CMakeLists.txt)
        -so you don't always have to find the CMakeLists.txt folder
        -this didn't work for me, but looked like it worked for him on linux
    -you can generate the project (where cmake_cache) then build it
        msbuild project.sln /Flags
    -you can tell cmake to build for you
        cmake --build <dir> [options] [-- [native-options]]


///////////////////////////////////////////////////////////////////////////////////
//video 4: Adding Libraries
///////////////////////////////////////////////////////////////////////////////////
    cmds:
        cmake -D BUILD_SHARED_LIBS=true         //override default

    script:
        add_library(
            lib-name LIBRARY_TYPE
            lib-header.hpp
            lib-translation-unit.cpp
        )

        target_link_libraries(projectName LINK_INTERFACE_MODE libraryName)

    explanation
        library types are 
            STATIC      -standard static library
            SHARED      -dynamic link libraries? i believe it is linux terminology
            MODULE

        default libraries are STATIC, and thus it doesn't need to be specified
            changing the default can be done with cmd: cmake -D BUILD_SHARED_LIBS=true
///////////////////////////////////////////////////////////////////////////////////
//video 5: Using visual studio
///////////////////////////////////////////////////////////////////////////////////
    usage
        - "build modes" are associated with visual studio configurations
        - you can tell cmake to build the specific config (debug/release/etc) with --config cmd
        -visual studio can open a directory in cmake as if it was a project
            -just rightclick anywhere in the folder, and do open with visual studio
            -it browses like it is a project generated by visual studio
            -I believe it used a temporary directory
        ZERO_CHECK
            -makes sure that cmake configuration data is not out of date
            -if it is out of data, it will do the equvalient of "cmake .." in the build directories
            -this is always built (if needed) before building any other projects


    cmds:
        cmake --build <dir> --config CONFIGNAME
        cmake --build . --config Debug

        //i believe below specifies the startupt project?
        cmake --build . --config Debug --target simple

///////////////////////////////////////////////////////////////////////////////////
//video 6
///////////////////////////////////////////////////////////////////////////////////
    cl.exe and link.exe are window's compiler and linker
    cl.exe uses environment variables for include paths and libraries
        pwsh opens power shell, 
            ls env prints all environment vars
        echo $env:INCLUDE
            -include paths separated with ;
        echo $env:LIB
            -semicolon separated list of where linker searches for library files
    Continuous Integration
        -to get compiling in command prompt:
            run: "ProgramFiles(x86)\MicrosoftVisualStudio\2017\BuildTools\VC\Auxillary\Build\vcvarsall.bat
            "vcvarsall.bat" -- adds cl.exe to path so it is ready to use; use without arguments to see options
            "vcvarsall.bat x64" -- prepares for x64 and adds cl.exe to the path for running
            -you can now compile like "cl main.cpp" 
    nmake -- like unix make; uses makefiles (note -G specifies a build system generator; https://cmake.org/cmake/help/v3.5/manual/cmake.1.html )
        //below ran within build folder
        cmake -G "NMake Makefiles" ..       --builds files for window's nmake
        uses non-standard Makefile

    ninja -- designed to compile source files in parallel; built for chromium compilation
        -- configure with ninja --
        //below ran within build folder
        cmake -G Ninja ..               //this will attempt to use gcc
        cmake -G Ninja -DCMAKE_C_COMPILER=cl -DCMAKE_CXX_COMPILER=cl ..     //tells cmake not to use gcc, but cl.exe

        --build with ninja --
        ninja cmake

///////////////////////////////////////////////////////////////////////////////////
//video 7 CMake within visual studio code
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
//video 8 Subdirectories and Target Interface Properties
///////////////////////////////////////////////////////////////////////////////////

    scripting:
        add_subdirectory(cmake_project_subdirectory_name)
            -allows you to add asubdirector with a CMakeLists.txt
            -looks like you will need a lot of CMakeLists.txt in subdirectories. ugh.

        target_include_directories(<lib_name> LINK_INTERFACE LIST_DIRECTORIES)
        target_include_directories(HelloLibrary PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/src")
            -public makes whoever links this library add the #include path to their #include paths

        target_compile_definitions(HelloLibrary PUBLIC PREPROCESSOR_MACRO_DEF=4)
            -warning, this will be for anyone who includes the library!

        target_compile_definitions(HelloLibrary PRIVATE PREPROCESSOR_MACRO_DEF=4)
            -this will not be defined in users of the library because it is PRIVATE
            -it will only be defined in the library's source code

        target_compile_definitions(HelloLibrary INTERFACE PREPROCESSOR_MACRO_DEF=4)
            -this will be present only in linkers of the library, not the library itself
    
    INCLUDE_LINK_INTERFACES
        PUBLIC
            -anyone including this library will also need these header files added to their include directories
        PRIVATE


///////////////////////////////////////////////////////////////////////////////////
//video 9: Scripting Basics
///////////////////////////////////////////////////////////////////////////////////
    Two types of scripts
        -configure scripts
        -plain context scripts

    -imperative scripting
    -series of commands (which are functions)
        command_name(LIST OF ARGUMENTS)
            -cannot do multiple commands on single line
            -every argument is a string, whether or not it is wrapped in quotes
            -whitespaec doesn't matter (other than no two commands on single line)
        # this is a comment!
    -configure mode scripts
        -always start with command declaring minimum required cmake version
            cmake_minimum_required(VERSION 3.12)
        -very soon after this, you will want to add a project call 
            project(MyProjectName VERSION 1.0.0)

    message function    -- prints message to console
        message(MODE Strs Will Smash)    #all arguments will be concatented, StrsWillSmash; add quotes to prevent
        message(STATUS "These strs are one str and will have spaces" ) #

    set command -- lets setting of variables
        set(VAR_NAME value)

        set(MY_VARIABLE "I am a variable" )
        message(STATUS "${MY_VARIABLE} is the value of variable")

    some varaibles definied in the config
        PROJECT_NAME
        PROJECT_VERSION


///////////////////////////////////////////////////////////////////////////////////
//video 10 control flow
///////////////////////////////////////////////////////////////////////////////////
    -if statements and loops automatically deference variable names 
        -this behavior was added in very early cmake
    -control flow have designated end() 
    STREQUAL -- is used to do string comparesion
    EQUAL --is used to do arithmetic comparisions
    MATCHES -- is used to do regex matching
    -loop types
        WHILE
        FOREACH
    RANGE -- creates an inclusive range, option arguments to specify 'start' 'end' and 'step'

    example code
        # --------------------------- 
        set(myBool TRUE)
        if(myBool) #same as "${myBool}"
            message(STATUS "Using vars in branches")
        endif()
        # --------------------------- 
        set(STR_A "abc")
        set(STR_B "abc")
        set(STR_C "xyz")

        #note that str "abc" is a literal, and the variable STR_A is auto-deferenced
        if( (STR_A STREQUAL "abc") AND NOT (STR_B STREQUAL "abc")) #it appears not has to go outside parenthesis
            message(STATUS "Complex condition")
        else if(STR_A MATCHES "c$")
            message(STATUS "var ends with c")
        endif()
        # --------------------------- 
        #equal is for arithmetic comparisons
        set(x "1")
        if(x EQUAL "1")
            message(STATUS "arithmetic value match")
        endif()
        # --------------------------- 
        set (iter 0)
        while(iter LESS 10)
            message(STATUS "iter value is ${iter}")
            math(EXPR iter "${iter} +  1")
        endwhile()
        # --------------------------- 
        foreach(item IN ITEMS foo bar baz qux)
            message(STATUS "item is ${item}")
        endforeach()
        # --------------------------- 
        foreach(idx RANGE 0 10 2) #start, inclusive_end, step_size
            message(STATUS "idx is ${idx}") 
        endforeach()

///////////////////////////////////////////////////////////////////////////////////
//video 11 Functions Scopes Arguments and Lists
///////////////////////////////////////////////////////////////////////////////////
    -cmake has a concept of properties
        -there are global properties, which are retrived with 
            get_cmake_property(out_var_name PROPERTY_NAME)
        -there are directory (and other) properties; they're retreived with
            get_property(out_var_name PROPERTY_NAME)

        properties are defined like:
            set_property(
                SCOPE
                "PROPERTY" PROPERTY_NAME
                LIST_OF_VALUES_FOR_PROEPRTY
            )
    -list expansion happens when you do not use quotes around variable dereferencing
        "${list}"   #variable dereferencing
        ${list}     #list expansion, this can be used to expand a list into multiple arguments (rather than 1 string); useful for passing to function
    
    -you can write functions
        -functions copy the global scope variabels into 
        -any set commands acts to set local variables
        -you can set variables of the parent scope, by adding an argument to the set command
            -the argument is PARENT_SCOPE
            set(retVal "${newVAL}" PARENT_SCOPE)
            -functions can take multiple arguments variadic arguments
                -there's special variables for retreiving these arguments
                    ARGN --a list of the un-named arguments (ie those without parameter names)
                    ARGV --a list of all arguments passed to function, including those with names
            
    code examples
        PROPERTIES:
            set_property(        #all arguments below are just strings, and have quotes around them
                GLOBAL           #GLOBAL argument specifying global scope; acts kind of like an enum
                PROPERTY FOO    #property is 'acting' as keyword specifier; foo is acting as property name
                1
                2
                3
            )
            get_cmake_property(out_var_name FOO)
            message(STATUS "property FOO has value ${out_var_name}")  #property FOO has value 1;2;3
        FUNCTIONS
            /--------------
            function(variadicFunc FIRST)
                message(STATUS "printing unnamed args")
                foreach(arg IN LISTS ARGN)
                    message(STATUS "${arg}")        #will not print JOE
                endforeach()

                message(STATUS "\nprinting NAMED args")
                foreach(all_args IN LISTS ARGV)
                    message(STATUS "${all_args}")  #will print joe
                endforeach()
            endfunction()
            variadicFunc(joe doe lily smoe)
            /--------------
            function(increment var)
                message(STATUS "value before increment ${${var}}") #first deference gets variable name, second deference gets value
                math(EXPR localVar "${${var}} + 1")
                set("${var}" "${localVar}" PARENT_SCOPE)
            endfunction()

            set(myValue 5)
            increment(myValue)
            message(STATUS "value after increment ${myValue}")
            /--------------




///////////////////////////////////////////////////////////////////////////////////
//video 12 cmake_parse_arguments
///////////////////////////////////////////////////////////////////////////////////
    -parse arguments seems to behave to a siilar concept as std::pair; but not 100% match
    -it matches a KEYWORD argument to an argument
        -cmake scripts manytimes will require pairs of arguments; the first being a keyword, the second being its value
        eg: setproperty
            set_property(
                GLOBAL
                PROPERTY foo        //property is the keyword, foo is the value for that property
                ${a_list}
            )
    -you can test if a variable is defined, using the the "defined" keyword
        -it tests if a variable has been set
            if(DEFINED a_var)
                message(STATUS "a_var is defined")
            else()
                message(STATUS "a_var is NOT defined")
            endif()

    CODE SAMPLE
            # ----------------------------
            function(namedArgFunction)
                set(options PRINT_HI)
                set(args NAME SRC)
                set(list_args ARGVs)
                cmake_parse_arguments(      
                    PARSE_ARGV 0                #MODE, numArgsToSkip
                    test                        #variable prefix
                    "${options}"                #list of options for our parse (these are custom that we can provide); they're boolean values
                    "${args}"                   #the keyword arguments to find (we're going to pass NAME and SRC)
                    "${list_args}"              #keyword associated with more than one value
                )

                #cmake_parse_arguments will create a list of arguments it did not parse; prefixed with the giving prefix
                foreach(arg IN LISTS test_UNPARSED_ARGUMENTS)
                    message(STATUS "unparsed ${arg}") 
                endforeach()

                #parsed arguments get the prefix appended before the variable name
                message(STATUS "NAME is ${test_NAME}")  
                message(STATUS "SRC is ${test_SRC}")    
                message(STATUS "TEST_ARGV is ${test_ARGVs}")
                if(test_PRINT_HI)
                    message(STATUS "HI! You passed this option :3")
                endif()
            endfunction()

            #-- unparsed EXTRA
            #-- unparsed lol
            #-- text NAME is blue
            #-- text SRC is brain
            #-- TEST_ARGV is one;two;three
            #-- HI! You passed this option :3
            namedArgFunction(
                NAME "blue"
                SRC "brain"
                EXTRA "lol"
                PRINT_HI                    #this is an option
                ARGVs "one" two "three"
            )

            message(STATUS "\n\n\n\n")
            # ----------------------------




///////////////////////////////////////////////////////////////////////////////////
//video 13
///////////////////////////////////////////////////////////////////////////////////

    cmds    
        cmake -P script.cmake   //this runs cmake in script mode! good for testing

    -you can add functions to files to be used in multiple CMakeList.txt
        -these functions are added to files ending in .cmake
        -eg: "log_functions.cmake" could contains custom functions for easy logging'
        -you will need to use the include command the cmake files, like below:
            include(log_functions.cmake)
                -this command will propagate to all subdirector projects
                    -this is propagation is risky
                    -it means, you may be relying on includes from parent directories...
                    -which means the cmake list might not be portable

    -also, he adds "project" to the subdirectory CMakeLists.txt files; this is probably good practice

    -subdirectories
        -when running from a top level, the subdirectories are put in folders within the build directory
            eg project structure
                ROOT
                    CMakeLists.txt
                    DIR_EXEC
                    DIR_LIB
                    build
            will put build contents of DIR_EXE into
                ROOT/build/DIR_EXEC
            will put build contest of DIR_LIB into
                ROOT/build/DIR_LIB
            will put build contents of ROOT into
                ROOT/build/
            so build will look like
                build
                    ...stuff from root
                    DIR_EXE
                        ...stuff from DIR_EXE
                    DIR_LIB
                        ...stuff from DIR_LIB

    -why is it "lists" in the name: CMakeLists.txt ?
        -I'm not sure, but after reviewing all this, it seems helpful to think of that file as
        a cmake "list" of commands
        -though, this probably isn't what it really is -- but thinking as such gives you an expectation of what to find there

    -add_subdirectory command
        add_subdirectory(executable_dir)    --executable_dir is a relative path
        add_subdirectory(executable_dir differentBinaryDir) --differentBinaryDir is a different relative path (from build dir) to put binaries
            -this means the user can change output of binary files!

    -cmake scripting mode:
        cmake -P script_file
            -this will run the script file


///////////////////////////////////////////////////////////////////////////////////
 